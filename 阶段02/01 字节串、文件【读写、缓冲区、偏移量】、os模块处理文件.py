# #终端运行 Python程序
#
# #第一种：
#    python3  xx.py
#
# #第二种：
#    #!/usr/bin/python3
#
#    chmod 766 xx.py
#
#    ./xx.py







"""
字节串类型
 字节串是二进制，给计算机看的，给计算机传输或者保存到硬盘【照片、视频，压缩包，音乐】
 字符串是文本，给人看的，用来操作的

* 所有字符串都能转换为字节串【字符串到二进制】
* 并不是所有的字节串都能转换为字符串【并不是所有二进制都跟字符有对应关系】
"""

#
# # 字符串转换成字节串：
# b1 = b"hello world"  # 双引号里是英文字符
# print(type(b1))
#
# b2 = "你好".encode() # 把utf8【包含中文的字符串】字符定义为字节串
# print(b2)
#
# s = "hello ,死鬼"
# b3 = s.encode()     # 变量使用encode转换
# print(b3)
#
#
#
# # 字节串转换为字符串，如下把字节串变量b3，转换成字符串
# print("转换为字符串：",b3.decode())
#
#







"""
文件读取 
  打开文件
  读取文件
  关闭文件
  
  r：以只读模式打开文本文件，文件必须存在，默认就是r
  w ：以写方式打开，文件不存在则创建，存在清空原有内容  
    f = open("file.txt","w")   
      
  a ：以追加模式打开，文件不存在则创建，存在则继续进行写操作 
    f = open("file.txt","a")
    
  r+ ：以读写模式打开 文件必须存在，从头开始写，并且不断覆盖原有的字符串
      f = open("file.txt","r+")                          
  w+ ： 以读写模式打开文件，不存在则创建，存在清空原有内容     
  a+ ： 追加并可读模式，文件不存在则创建，存在则继续进行写操作 
"""

# # 打开文件，只读方式
# f = open("/root/PycharmProjects/pythonProject/阶段02/dict.txt",'r')



# # 读取文件内容
# data = f.read() # 不加参数表示获取文件所有内容
# print("读取到的内容:",data)



# # 对于大文件通常都会分块循环读取
# while True:
#     data = f.read(1024)     #每次读1024个字符【一般都是1024的整数倍】，读取到文件结尾继续读取，则会得到空字符串
#     if not data:
#         break
#     print(data,end='')      #不加end=''的话，就读取指定字符的文本后，就换行了，加了后，就不换行
#


# #读取第一行，执行两次就是读取前两行
# data = f.readline()
# print("一行内容:",data)
# data = f.readline()
# print("一行内容:",data)



# data = f.readline(10)    # 读取到第一行10个字符或者遇到换行都会终止读取
# print("一行内容:",data)
# data = f.readline()      #读取第一行剩下的所有内容
# print("一行内容:",data)
#




# #读取全部内容，每一行作为列表的一个元素
# data_list = f.readlines()
# print(data_list)



# # 读取多行内容 文件每一行读取为列表中一个元素
# #如下读取62个字符，假设第62个字符出现在第三行，则读取的就是前三行全部字符，而不是只读取到第62个字符
# data_list = f.readlines(62)
# print(data_list)
#



# # # 迭代获取，每次迭代，获取到的内容，就是一行
# for line in f:
#     print(line,end='') # 每次获取一行



# # 关闭文件
# f.close()









'''
练习1：使用input输入一个单词，打印出这个单词的解释
     如果没有这个单词则打印"没有找到该单词"
提示：
    * 每个单词占一行
    * 单词与解释之间有空格
    * 单词按照从小到大排列
'''

# # 输入一个单词
# word = input("Word:")
#
# # 打开字典文件，默认就是读
# f = open("/root/PycharmProjects/pythonProject/阶段02/dict.txt")
#
# # 查找单词
# for line in f:
#     w = line.split(' ',2)    #以空格为分隔符，分割成列表，只切割两次
#     if w[0] > word:          # 遍历到的单词已经大于目标就没必要继续找了
#         print("没有该单词")
#         break
#     elif word == w[0]:       # 找到单词 打印   # print(w[-1].strip())，去掉首位空格和换行
#         print(line)
#         break # 结束查找
# else:
#     print("没有找到该单词")
#
# # # 关闭文件
# f.close()
#







"""
文件写操作示例
 w ：以写方式打开，文件不存在则创建，存在清空原有内容  
    f = open("file.txt","w")   
      
 a ：以追加模式打开，文件不存在则创建，存在则继续进行写操作 
    f = open("file.txt","a")
    
 r+ ：以读写模式打开 文件必须存在，从头开始写，并且不断覆盖原有的字符串
      f = open("file.txt","r+")                          
 w+ ： 以读写模式打开文件，不存在则创建，存在清空原有内容     
 a+ ： 追加并可读模式，文件不存在则创建，存在则继续进行写操作 


"""

# 以写方式打开，当前目录下的file.txt文件
f = open("file.txt","w")


# 写入操作，返回值是写入的字符个数
# n = f.write("Hello world\n")
# print("写入了 %d 个字符"%n)     #12
# n = f.write("你好，世界\n")    #6
# print("写入了 %d 个字符"%n)


# 将列表中的每个元素，分别写入到文件中，
# 但是要加上换行\n，否则写到同一行了
# l = ["哈喽，死鬼\n","哎呀，干啥\n"]
# f.writelines(l)


# 关闭文件
f.close()







'''
上面的都是文本文件的读写，下面二进制文件的读写：


练习2： 文件的复制

下载一个图片（二进制文件），将这个文件下载到主目录
编写程序，将这个文件复制到当前程序所在目录中

提示： 从原文件读内容，写到新文件
      不允许一次性读取所有内容


rb  ： 以二进制读模式打开 同r    
wb  ： 以二进制写模式打开 同w    
ab  ： 以二进制追加模式打开 同a  
rb+ ： 以二进制读写模式打开 同r+ 
wb+ ： 以二进制读写模式打开 同w+ 
ab+ ：以二进制读写模式打开 同a+ 

'''
# #以二进制，读，模式打开源文件
# f01 = open("/root/Pictures/风景.jpeg",'rb')
# #以二进制，写，模式创建新文件
# f02 = open("/root/PycharmProjects/pythonProject/阶段02/风景.jpeg",'wb')
#
# #一边读取，一边写入
# for line in f01:
#     f02.write(line)
#
# #或者如下，一边读取，一边写入
# # 如果上面的代码跟下面的代码同时存在，则只上面的代码有效，因为文件已经读完了
# while True:
#     data = f01.read(1024)
#     if not data:
#         break
#     f02.write(data)
#
# #关闭文件
# f01.close()
# f02.close()
#






"""
with语句块 
    读写完文件后，自动释放文件，不需要close
"""
# # 生成文件对象f
# # 语句块结束会自动销毁 f
# with open('file.txt','rb+') as f:   #以二进制读写方式打开文件，
#     data = f.read(10)               #读取前面10个字节
#     print(data.decode())            #转换成字符串
#     f.write(b"hahahahaaaa")            #从第11个字节写入字节串
#
#









"""
缓冲区
    一般保持默认就行

* 定义
  系统自动的在内存中为每一个正在使用的文件开辟一个空间，在对文件读写时都是先将文件内容加载到缓冲区，再进行读写。
* 作用
  1. 减少和磁盘的交互次数，保护磁盘。
  2. 提高了对文件的读写效率。

* 缓冲区设置
  | 类型           | 设置方法     | 注意事项                   |
  | -------------- | ------------ | -------------------------- |
  | 系统自定义     | buffering=-1 | 默认就是这个                  |
  | 行缓冲        | buffering=1  | 当遇到\n时【换行】刷新缓冲 |
  | 指定缓冲区大小 | buffering>1  | 必须以二进制方式打开文件   |

* 刷新缓冲区条件【刷新缓冲区，即什么时候，缓冲区跟磁盘，进行内容交互】
    1. 缓冲区被写满
    2. 程序执行结束或者文件对象被关闭【一般都是这种】
    3. 程序中调用flush()函数，主动刷新缓冲区
        file_obj.flush()
"""

# #  行缓冲
# f = open('file.txt','w',buffering=1)
#
# # 循环写入内容
# while True:
#     info = input(">>")
#     if not info:  # 空的话，即直接回车的话，就退出循环，才会执行close
#         break
#     f.write(info+'\n')  #由于换行缓冲，所以不执行close，也会在文件里实时看到输入的内容
#
# f.close()
#



# # # 指定缓冲区大小，必须以二进制打开
# # # 够10个字节后，才会刷新缓冲区，把这10个字节存到磁盘
# f = open('file.txt', 'wb', buffering=10)
#
# # 循环写入内容
# while True:
#     info = input(">>")
#     if not info:  # 空的话，即直接回车的话，就退出循环，才会执行close，才会在文件里看到输入的内容，除非主动刷新f.flush()
#         break
#     f.write(info.encode())#字符串转换成字节串，才能写入
#     #f.flush()       # 主动刷新缓冲区
#
# f.close()
#





'''
文件偏移量

* 定义
  打开一个文件进行操作时,系统会自动生成一个记录，记录每次读/写操作时,所处的文件位置，
  每次文件的读/写操作,都是从这个位置开始进行的。

  > 注意：
  > 1. r或者w方式打开，文件偏移量在文件开始位置
  > 2. a方式打开，文件偏移量在文件结尾位置


* 文件偏移量控制

  tell()
  功能：获取文件偏移量大小，即从头开始数，第多少个字节处
  返回值：文件偏移量，即从头开始数，第多少个字节处


  seek(offset[,whence])
  功能: 移动文件偏移量位置
  参数：offset  代表相对于某个位置移动的字节数，负数表示向前移动，正数表示向后移动。
       whence是基准位置，默认值为 0，代表从文件开头算起，
                              1，代表从当前位置算起，
                              2，代表从文件末尾算起。
  > 注意：必须以二进制方式打开文件时，基准位置才能是1或者2
'''




"""
文件偏移量演示
"""
#
# f = open("file.txt",'w+')
#
# f.write("Hello world!\n")
#
# f.flush()    #刷新缓冲区，写入磁盘
#
# print(f.tell()) #打印此时文件偏移量位置，即从头开始数，第多少个字节处
#
# # 从文件偏移量所在位置读，
# # 此时虽然已经写入了，但是是读不到的，因为此时文件偏移量在最后
# data = f.read()
# print(data)
#
#
# f.close()




# #二进制打开、写入
# f = open("file.txt",'wb+')
#
# f.write(b"Hello world!\n")
# f.flush()    #刷新缓冲区，写入磁盘
# f.seek(-2,2) # 文件偏移量从结尾向前移动2字节
# print("当前文件偏移量位置:",f.tell())
# data = f.read() # 从文件偏移量所在位置读，由于文件偏移量向前移动了2字节，所以此时可以读到最后两字节的数据
# print(data)
#
# f.close()
#



"""
文件偏移量演示
    空洞文件
"""
# #二进制，只写，打开文件
# f = open("file.txt",'wb')
#
#
# f.write(b"begin")   #二进制写入begin，5字节，
# f.seek(100000,2)    #然后文件末尾开始，文件偏移量向后移动10w字节
# f.write(b'end')     #然后再写入end 3字节，总共才写入8字节数据，但是linux查看文件大小，发现文件占用空间是10w零8字节
#                     #-rw-r--r-- 1 root root  100008 Aug  4 07:43 file.txt
#
# f.close()





'''
练习3： 在一个文件 my.log 中不间断的写入如下内容
 序号    当前时间，每两秒写入一行
 1. 2020-01-01  14:15:16
 2. 2020-01-01  14:15:18
 3. 2020-01-01  14:15:20
 4. 2020-01-01  14:15:22
 5. 2020-01-01  14:15:24
 6. 2020-01-01  14:17:29
 7. 2020-01-01  14:17:31

 每个时间占一行，每隔2秒写入一行
 当程序终止以后，下次启动，要求序号能够衔接，继续写
 写的内容每写入一行就要在文件中显示

 提示 ： import time
        sleep()

'''
# import time
#
# f = open("my.log","a+",buffering=1) # 行缓冲
#
# n = 1
# f.seek(0,0) # 把文件偏移量放到开始，是因为程序终止后，a+模式打开文件，文件偏移量在文件结尾
#
# for i in f: # 程序终止后，再次运行，n 应该等于已有行数 + 1
#     n += 1
#
# while True:
#     time.sleep(2) # 时间间隔2s
#     msg = "%d. %s\n"%(n,time.ctime())
#     f.write(msg)
#     n += 1
#
# f.close()










"""

os模块，处理文件

"""
#
# import os
#
# # 获取文件大小【单位是字节】，跟linux里用ll命令看到的大小一样
# print(os.path.getsize("./dict.txt"))
#
# # 获取一个目录中所有文件名[返回值是列表]
# print(os.listdir("./"))
# # 判断文件是否存在
# print(os.path.exists("./dict.txt"))
#
# # 是否为普通文件[即非目录]
# print(os.path.isfile("./dict.txt"))
#
# # 删除文件
# #os.remove("./dict.txt")
#


'''

练习2：
通过input输入一个目录（目录中有很多文件可能有文件夹），
删除这个目录中所有大小小于10字节的普通文件

'''
# import  os
#
# dir=input("输入目录：")
#
# for item in os.listdir(dir):
#     print(item)
#     if os.path.isfile(dir+"/"+item):
#         if os.path.getsize(dir+"/"+item) < 10:
#             os.remove(dir+"/"+item)