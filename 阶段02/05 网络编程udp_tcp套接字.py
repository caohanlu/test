'''
 UDP套接字编程

import  socket

* 创建套接字
sockfd=socket.socket(socket_family,socket_type,proto=0)
功能：创建套接字
参数：socket_family  网络地址类型 , AF_INET表示ipv4
	 socket_type    套接字类型 ,  SOCK_DGRAM表示udp套接字
	 proto          通常为0,选择子协议，默认就是0
返回值： 套接字对象



* 绑定地址【在服务器上绑定服务器自己对外提供服务的地址、端口】
sockfd.bind(addr)
功能： 绑定本机网络地址
参数： 二元元组 (ip,port)  例如('0.0.0.0',8888)
    ip可以如下：
  * 本地地址 ： 'localhost' , '127.0.0.1'，                 只能本机访问该服务
  * 网络地址 ： '172.40.91.185'                             通过ifconfig查看 只能通过该ip访问该服务
  * 自动获取地址： '0.0.0.0'，                               一般都用这个，可以通过本机上所有地址，访问该服务

    绑定ip，如下三种，只能选择一种方式，否则报错
    udp_socket.bind(('0.0.0.0',8888))

    udp_socket.bind(('127.0.0.1',8888))
    udp_socket.bind(('localhost',8888))

    udp_socket.bind(('192.168.3.201',8888))



* 收消息发
data,addr = sockfd.recvfrom(buffersize)
功能： 接收UDP消息
参数： 每次最多接收多少字节,
      例如1024字节，如果对端发送的数据大于1024字节，多出的部分就会被丢掉
      一个字母占一个字节，一个汉字占三个字节
      所以需要人为预估对端发来的数据大小
返回值： data  接收到的内容,二进制字节串格式
	    addr  消息发送方地址、端口


* 发消息
n = sockfd.sendto(data,addr)
功能： 发送UDP消息
参数： data  发送的内容 ，bytes字节串格式
	  addr  目标地址、目标端口
返回值：发送的字节数





* 关闭套接字
sockfd.close()
功能：关闭套接字







1.2.4  UDP套接字特点
* 可能会出现数据丢失的情况
* 传输过程简单，实现容易
* 数据以数据包形式表达传输
* 数据传输效率较高

'''







'''

tcp服务端

- 创建套接字
sockfd=socket.socket(socket_family,socket_type,proto=0)    #默认参数就是ipv4 tcp
功能：创建套接字
参数：socket_family  网络地址类型 AF_INET表示ipv4
	 socket_type    套接字类型 SOCK_STREAM 表示tcp套接字 （也叫流式套接字） 
	 proto          通常为0  选择子协议
返回值： 套接字对象




- 绑定地址 （与udp套接字相同）
sockfd.bind(addr)   【在服务器上绑定服务器自己对外提供服务的地址、端口】
功能： 绑定本机网络地址
参数： 二元元组 (ip,port)  例如('0.0.0.0',8888)
    ip可以如下：
  * 本地地址 ： 'localhost' , '127.0.0.1'，                 只能本机访问该服务
  * 网络地址 ： '172.40.91.185'                             通过ifconfig查看） 只能通过该ip访问该服务
  * 自动获取地址： '0.0.0.0'，                               一般都用这个，可以通过本机上所有地址，访问该服务

    绑定ip，如下三种，只能选择一种方式，否则报错
    udp_socket.bind(('0.0.0.0',8888))

    udp_socket.bind(('127.0.0.1',8888))
    udp_socket.bind(('localhost',8888))

    udp_socket.bind(('192.168.3.201',8888))




* 设置监听
sockfd.listen(n)
功能 ： 将套接字设置为监听套接字【则可以被客户端连接】，
       以及确定监听队列大小：
           一个套接字可以跟1024个客户端建立连接，但是建立连接的过程三次握手得一个个来,
           假设同时有很多客户端要建立连接，此时可以开辟队列，队列里的可以一个个依次建立连接，
           剩下的连接会被拒绝，需要客户端重新发起连接请求，等队列里的第一个连接建立好了后，才能挤到队列里排队
           linux下，这个参数随便写，都无所谓，写1,2,3,4,5都一样，因为操作系统已经设定好了队列，但是在别的系统下，这个参数有用
参数 ： 监听队列大小






* 处理客户端连接请求、三次握手建立tcp连接
connfd,addr = sockfd.accept()
功能：   阻塞等待、处理客户端请求【跟tcp客户端的sockfd.connect(server_addr)成对出现，如果没有客户端请求，则一直等待】
返回值： connfd  客户端连接套接字
                    跟建立连接的客户端相对应的套接字，与客户端之间的消息收发，使用该套接字，
                    连接套接字跟客户端之间，是一一对应关系
        addr   连接的客户端地址





* 消息收发【使用连接套接字connfd】
data = connfd.recv(buffersize)   
功能 : 接受客户端消息
返回值： 接收到的内容【返回值没有客户端的地址、端口，因为连接套接字跟客户端之间是一一对应的关系】
参数 ：每次最多接收消息的大小字节

          1024是1kB，1024*1024是1MB
          tcp的接收端，实际上是从接收端的网络缓冲区里，拿收到的数据的，
          假设每次只能拿5字节数据，但是对端发送了15字节，则接收端的缓冲区里有15字节
          所以要分三次从接收端缓冲区里拿数据，假如对端发送hello，world！，则服务端接受如下
            Recv: hello
            Recv: ,worl
            Recv: d!
          即如下循环要执行三次，才能拿到缓冲区里的所有数据，这点跟udp不一样，udp直接丢掉超过指定的字节数的数据
          假设服务端代码如下，
            while True:
            data = connfd.recv(5)
            if not data:   
                break
            print("Recv:",data.decode())
            connfd.send(b"Thanks")
         由于服务端执行三次循环，所以服务端给客户端发了三次connfd.send(b"Thanks")
         
         假设客户端如下
            while True:
                msg = input(">>")
                if not msg:
                    break
                tcp_socket.send(msg.encode()) # 发送字节串
                data = tcp_socket.recv(1024)
                print("From server:",data.decode()) # 转换字符串
         由于三次Thanks到达客户端的缓冲区，受网络质量影响，有可能一个一个到，也有可能一次全到，
         所以客户端recv的时候，有可能一次取出一个或两个或三个Thanks,如下
         From server: ThanksThanks
         
         假设客户端recv的时候，还有数据没接受完，就close套接字了，
         则服务端报错ConnectionResetError: [Errno 104] Connection reset by peer
         
         网络缓冲区，不同操作系统不一样，是系统定义的，
         所以一般都是一边发送，一边接受，即循环发送接受数据，
         而不是把一次性接受的数据data = connfd.recv(buffersize) ，设置成很大的值，设置了也没用


n = connfd.send(data)
功能 : 发送消息
参数 ：要发送的内容  二进制字节串bytes格式  【不用指定客户端地址、端口，因为连接套接字跟客户端之间是一一对应的关系】
返回值： 发送的字节数




6. 关闭套接字 (与udp套接字相同)
sockfd.close()















#### 1.3.3 TCP客户端 

* 创建TCP套接字
跟服务端一样


* 请求连接【对应服务端的accept】
sockfd.connect(server_addr)
功能：连接服务器
参数：元组,服务器地址


* 收发消息
防止两端都阻塞，recv send要配合,
例如客户端发消息的话，则服务端就要收消息，不能两端都收消息，就都在等对方发消息了


* 关闭套接字
跟服务端一样











#### 1.3.4 TCP套接字细节

* tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字节串。【即一端close了，另一端recv会返回空，而不是通过网络发来一个空】


* tcp连接中如果一端已经不存在，仍然试图通过send向其发送数据,则会产生BrokenPipeError,报错



* 一个服务端可以同时连接多个客户端，也能够重复被连接



* tcp粘包问题：
        即多次发送的消息，被一次recv了，
        一般都是循环发送的场景下会发生
        
      * 产生原因
        * 为了解决数据再传输过程中可能产生的速度不协调问题，操作系统设置了缓冲区
        * 实际工作中，网络工作过程比较复杂，导致消息收、发速度不一致，假设发送速度，大于recv速度，则多次发送的内容，会就被堆积在recv端的网络缓冲区
        * tcp以字节流方式进行数据传输，在接收时不区分消息边界，udp没有粘包问题，因为每次recv只recv一个包
        
      * 带来的影响
        * 如果每次发送内容是一个独立的含义，需要接收端独立解析，此时粘包会有影响。
        例如用户名、密码分开发送，但是被一次recv，合成一个消息了，就会有影响
        但如果是二进制的图片、视频，则粘包问题没有影响，因为最终都是合成一个文件了
    
      * 处理方法
        * 人为的添加消息边界，用作消息之间的分割
                例如服务端回消息的时候，加个特殊符号#，connfd.send(b"Thanks#")
                客户端recv的时候，即使沾包了也没事，如下，多个消息之间被#隔开了
                >>hello,world!
                From server: Thanks#Thanks#Thanks#
        * 控制发送的速度
            例如每次发送之前，sleep 0.1s 但是如果发送的次数很多，则影响效率















#### 1.3.5 TCP与UDP对比

* 传输特征
  * TCP提供可靠的数据传输，但是UDP则不保证传输的可靠性
  * TCP传输数据处理为字节流，而UDP处理为数据包形式
  * TCP传输需要建立连接才能进行数据传，效率相对较低，UDP比较自由，无需连接，效率较高

* 套接字编程区别
  * 创建的套接字类型不同
  * tcp套接字会有粘包，udp套接字有消息边界不会粘包
  * tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要
  * tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom
  
* 使用场景
  * tcp更适合对准确性要求高，传输数据较大的场景
    * 文件传输：如下载电影，访问网页，上传照片
    * 邮件收发
    * 点对点数据传输：如点对点聊天，登录请求，远程访问，发红包
  * udp更适合对可靠性要求没有那么高，传输方式比较自由的场景
    * 视频流的传输： 如直播，视频聊天
    * 广播：如网络广播，群发消息
    * 实时传输：如游戏画面
  * 在一个大型的项目中，可能既涉及到TCP网络又有UDP网络





'''