'''
总结：

 元字符

   匹配重复：  *  +  ?  {n}  {m,n}
   匹配字符：  .  [] [^] \d \D \w \W \s \S
   匹配位置： ^  $   \b   \B

正则匹配规则

   * 匹配特定字符：  $ --> \$
   * 贪婪非贪婪 ：   ab+ --> ab+?
   * 分组：  ()  (?P<name>xxxxxx)



'''




### 2. 正则表达式
# 		对文本内容的搜索，定位，提取
# 		而linux的通配符，只对文件名的通配
# > 注意：正则表达式在python中也可以匹配中文



# 普通字符
# 匹配规则：每个普通字符匹配其对应的字符
import re

#re.findall('ab',"abcdefabcd")  #查找右边的字符串里，有没有字符串ab，将返回值print出来，如下
# ['ab', 'ab']
# s=re.findall('你好',"你好世界")  #查找右边的字符串里，有没有字符串你好，将返回值print出来，如下
# print(s)
# ['你好']





# 或关系
# 元字符: |
# 匹配规则: 匹配 | 两侧任意的正则表达式即可
# s= re.findall('com|cn',"www.baidu.com/www.tmooc.cn")
# print(s)
# ['com', 'cn']
#
# s= re.findall('ab|bc',"abcd")  #ab跟bc，b重复了，只匹配到ab
# print(s)
#['ab']
#
#



# 匹配单个字符
# 元字符：.
# 匹配规则：匹配除换行外的任意一个字符
# re.findall('张.丰',"张三丰,张四丰,张五丰")
# ['张三丰', '张四丰', '张五丰']
#
# s=re.findall('张..',"张三丰,张四丰,张五丰")
# print(s)
# ['张三丰', '张四丰', '张五丰']
#
#
#





# 匹配字符集
# 元字符： [字符集]
# 匹配规则: 匹配字符集中的任意一个字符
#
# [abc#!好]           表示 [] 中的任意一个字符
# [0-9],[a-z],[A-Z]   表示区间内的任意一个字符
# [_-#?0-9a-z]         混合书写，一般区间表达写在后面
#
# s=re.findall('[aeiou]',"How are you!")
# print(s)
# ['o', 'a', 'e', 'o', 'u']
#
# s=re.findall('[a-zA-Z]',"How are you!")
# print(s)
#['H', 'o', 'w', 'a', 'r', 'e', 'y', 'o', 'u']
#







# 匹配字符集反集
# 元字符：[^字符集]
# 匹配规则：匹配除了字符集以外的任意一个字符
#
# re.findall('[^0-9]',"Use 007 port")
# ['U', 's', 'e', ' ', ' ', 'p', 'o', 'r', 't']
#
#
#
#






# 匹配字符串开始位置
# 元字符: ^
# 匹配规则：匹配以目标字符串开头
#
# list01=re.findall('^Jame',"Jame,hello")
# print(list01)
# ['Jame']
#
#
#
#



# 匹配字符串的结束位置
# 元字符:  $
# 匹配规则: 匹配以目标字符串结尾
#
# re.findall('Jame$',"Hi,Jame")
# ['Jame']
#
# 规则技巧: ^ 和 $ ，必然出现在正则表达式的开头和结尾处。
# 如果两者同时出现，则中间的部分必须匹配整个目标字符串的全部内容。
# list01=re.findall('^Jame$',"Jame")
# print(list01)
# ['Jame']
#
#








# 匹配字符重复
# 元字符: *
# 匹配规则：匹配前面的字符出现0次或多次
# re.findall('wo*',"wooooo~~w!")    #表示o字符，可以出现0次或者多次
# ['wooooo', 'w']
#
#









#
# 元字符：+
# 匹配规则： 匹配前面的字符出现1次或多次
# re.findall('[A-Z][a-z]+',"Hello World")
# ['Hello', 'World']
#
#







# 元字符：?
# 匹配规则： 匹配前面的字符出现0次或1次
# In [28]: re.findall('-?[0-9]+',"Jame,age:18, -26")    #匹配整数
# Out[28]: ['18', '-26']
#
#







#
# 元字符：{n}
# 匹配规则： 匹配前面的字符出现n次【指定的次数】
# re.findall('1[0-9]{10}',"Jame:13886495728")   #匹配手机号码
# ['13886495728']
#
#
#


# 元字符：{m,n}
# 匹配规则： 匹配前面的字符出现m-n次【例如{3,5}，即出现三次，或者四次，或者五次】
#  匹配qq号
# re.findall('[1-9][0-9]{5,10}',"Baron:1259296994")
# ['1259296994']
#
#
#
#




# 匹配任意（非）数字字符
# 元字符： \d   \D
# 匹配规则：\d 匹配任意单个数字字符，类似[0-9]
#         \D 匹配任意单个非数字字符，类似[^0-9]
# re.findall('\d{1,5}',"Mysql: 3306, http:80")   #匹配端口
# ['3306', '80']
#
#
#
#






# 匹配任意（非）普通字符
# 元字符： \w   \W
# 匹配规则:  \w 匹配单个普通字符，即数字、大小写字母、下划线、汉字
#          \W 匹配单个非普通字符
# re.findall('\w+',"server_port = 8888")
# ['server_port', '8888']
#
#
#
#





#匹配任意（非）空字符
# 元字符： \s   \S
# 匹配规则:  \s 匹配空字符，
#           \S 匹配非空字符
# 空字符指：空格  \r回车  \n换行  \t水平制表符【即tab，四个空格】
#          \v垂直制表符
#          \f 换页符
# re.findall('\w+\s+\w+',"hello    world")
# ['hello    world']
#
#
#
#






# 匹配（非）单词的边界位置
# 元字符： \b  \B
# 匹配规则： \b 表示单词边界
#          \B 表示非单词边界
# 说明：单词边界，指数字、字母(汉字)、下划线，与其他字符的交界位置。
#
#如下，精确匹配单词is
# list01= re.findall('\\bis\\b',"This is a test.")
# print(list01)
#或
# list01= re.findall(r'\bis\b',"This is a test.")
# print(list01)
# ['is']
#
# 注意： 当元字符符号，与Python字符串中，转义字符冲突的情况，
# 则需要使用r，将正则表达式字符串声明为原始字符串，即不转义
# 如果不确定那些是Python字符串的转义字符，
# 则可以在所有正则表达式前加r。
#
#如下，不会匹配到iPython，因为P前面是i，不是单词边界
# re.findall(r'\b[A-Z][A-Za-z]*',"Jame,I am iPython")
# ['Jame', 'I']













# 2.3 匹配规则

# 2.3.1 转义
# 目的 ： 如果匹配的目标字符串中,包含正则表达式特殊字符，
#        如果元字符就想表示其本身含义，就需要进行转义处理。
#
# 特殊字符: . * + ? ^ $ [] () {} | \
#
# 操作方法：在正则表达式元字符前加 \ ，则元字符就是去其特殊含义，就表示字符本身
#
#  如下匹配整数，负数，小数，
#  匹配特殊字符 . 时，使用 \. 表示本身含义
# re.findall('-?\d+\.?\d*',"123,-123,1.23,-1.23")
# ['123', '-123', '1.23', '-1.23']
#
#要对$进行转义\$，否则表达的就是以什么结尾
# list01=re.findall('\$\d+',"$100")
# print(list01)
# ['$100']
#
#





# 2.3.2 贪婪模式和非贪婪模式
# 贪婪模式:   默认情况下，匹配重复的元字符总是尽可能多的向后匹配内容。
#           比如这四种: *  +  ?  {m,n}
#
# 非贪婪模式(懒惰模式): 让匹配重复的元字符尽可能少的向后匹配内容。
#
# 贪婪模式转换为非贪婪模式：
#   在对应的匹配重复的元字符后加 '?' 号即可
    # *  ->  *?
    # +  ->  +?
    # ?  ->  ??
    # {m,n} -> {m,n}?
#例如ab*?  b出现0次或多次，加上？，变成b出现0次
# list01=re.findall(r'ab*?',"abbbbc")
# print(list01)
# ['a']
#
#
# list01 = re.findall(r'\(.+?\)',"(abcd)efgh(higk)")
# print(list01)
# ['(abcd)', '(higk)']
# 非贪婪模式，结果如上，贪婪模式就是['(abcd)efgh(higk)']
#
# 匹配所有书名，要用非贪婪模式，
# 否则列表里只有一个元素['《爱你不是两三天 》 《别走-2008》 《走吧-2020》《今天，你吃了吗？》']
# list01 =re.findall(r'《.+?》',"《爱你不是两三天 》 《别走-2008》 《走吧-2020》《今天，你吃了吗？》")
# print(list01)
# ['《爱你不是两三天》', '《别走-2008》', '《走吧-2020》', '《今天，你吃了吗？》']














##2.3.3 正则表达式分组
#
# 定义
#   在正则表达式中，以()建立正则表达式的内部分组，子组是正则表达式的一部分，可以作为内部整体操作对象。
#
# 作用 : 可以被作为整体操作，改变元字符的操作对象
#
#   改变 +号 重复的对象，
#   如下，则ab这个组，出现1次或者多次
# re.search(r'(ab)+',"ababababab").group()
# 'ababababab'
#
#
#  改变 |号 操作对象
# re.search(r'(王|李)\w{1,3}',"王者荣耀").group()
# '王者荣耀'
#
#








# 捕获组
#   捕获组本质也是一个子组，只不过拥有一个名称，用以表达该子组的意义，这种有名称的子组即为捕获组。
# 格式：(?P<name>pattern)
#
#  给子组命名为 "pig"，整体出现1或多次                只获取子组匹配到的内容,+的内容就不获取
# list01=re.search(r'(?P<pig>ab)+',"ababababab").group('pig')
# print(list01)
# 'ab'
#
# 子组整体后面跟的是非数字                                        只获取子组匹配到的内容
# list01=re.search(r'(?P<tel>1\d{10})\D*',"13122600020是我的电话").group('tel')
# print(list01)
#13122600020
#
# 子组嵌套
#   子组序列号一般从外到内，从左到右计数,如下
#       pattern = r"((\w+):(\d+))"
                # 第一组((\w+):(\d+))
                # 第二组(\w+)
                # 第三组(\d+)









